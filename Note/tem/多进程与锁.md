# 多进程与锁

### 为什么需要锁?

1. 多核时代
2. 保证正确性, race condition(竞态)
       eg: 把kfree的锁去掉就会发生page丢失

### 锁通常的作用

1. 避免丢失更新
2. 打包多个操作使其具有原子性
3. 维护共享数据结构的不变性

### 死锁

1. 连着acquire两次同一个锁
2. 两个锁交叉互相等待彼此

### 死锁解决

1. 全局锁排序

### 自旋锁的实现

1. 需要借助硬件实现, test-and-set操作, 对地址锁定

2. 不用处理器具体实现可能很不同与内存系统是如何工作的息息相关

3. acquire函数会先关闭中断, 为何?

   > 我们先来假设acquire在一开始并没有关闭中断。在uartputc函数中，首先会acquire锁，如果不关闭中断会发生什么呢？
   >
   > uartputc函数会acquire锁，UART本质上就是传输字符，当UART完成了字符传输它会做什么？是的，它会产生一个中断之后会运行uartintr函数，在uartintr函数中，会获取同一把锁，但是这把锁正在被uartputc持有。如果这里只有一个CPU的话，那这里就是死锁

4. __sync_synchronize函数来防止指令超出acquire和release以外

