# [mit6.S081]用户空间

[TOC]

## ch1笔记

### 概述

1. 内核和用户空间
2. 进程, 内存->包含了指令, 数据, 堆栈
3. 系统调用: 内核开放给用户的接口, 系统调用进入内核,内核执行服务并返回
4. 系统调用没有特殊说明, 成功返回0, 失败返回-1
5. 系统调用手册 --- p7

### 进程与内存

1. 一个xv6进程有用户空间内存和内核私有的进程状态组成
2. fork 创建一个内存与父进程完全相同的子进程, 父进程返回子进程PID, 子进程返回0
3. exit突出调用进程并释放资源, 如内存和打开的文件
   通常传入0表示成功, 1表示失败
4. wait等待一个子进程退出
   返回一个已退出的子程序PID, 可以传一个地址保存子程序的退出码(exit)
   没有子进程则返回0
5. exec使用新内存映像来替换进程的内存, 新内存影响从文件系统的文件中进行读取, 需要两个参数一个: 可执行文件的文件名 和 字符串参数数组(第一个通常为程序名称)
6. shell: 主循环用getcmd读取用户的一行输入, 然后调用fork. 父进程调用wait, 而子进程则运行命令
7. sbrk可以在进程运行需要更多内存时将其数据内存增长n个字节, 返回新内存的位置

### I/O 和 文件描述符

1. 文件描述符: 一个小整数, 代表一个可有进程读取或者写入的内核管理对象
   文件: 文件描述符所指向的对象称为文件
2. 每个进程单独维护一个以文件描述符为索引的表, 每个进程都有一个从0开始的文件描述符私有空间
3. 约定:  0标准输入;  1标准输出;  2标准错误(写入错误信息)
4. read(fd, buf, n) 从文件描述符fd读取不超n个字节
   write(fd, buf, n)从文件描述符fd写入buf中n个字节(buf如果小于n字节将发生错误)
5. 每个引用文件的文件描述符都有一个偏移量, 读取与写入 都会推进偏移量,随后的读取和写入都将从偏移处开始.  (读取时没有字节可读时返回0)
6. close 释放一个文件描述符, 使其可以被后面open, pipe和dup系统调用重用
   新分配的文件描述符总是当前进程中最小的未使用描述符
7. fork会将父进程的文件描述符表和他的内存一起复制, 因此子进程开始时打开的文件和父进程完全一致
   exec会替换进程的内存, 但会保留文件描述表
8. open(fs, sign) 打开文件并返回文件描述符
   sign可能的值(kernel/fcntl.h) : 
   `O_RDONLY`, `O_WRONLY`, `O_RDWR` , `O_CREATE` , 和 `O_TRUNC`它们指定 open 打开文件时的功能，读，写，读和写，如果文件不存在创建文件，将文件截断为零。
9. dup 复制一个现有的文件描述符, 返回一个新的描述符, 指向同一个底层I/O对象. 两个文件描述符共享一个偏移量
10. shell 快捷I/O重定向 < > >&

### Pipes--管道

1. 管道是一个小的内核缓冲区, 作为一对文件描述符暴露给进程, 一个用于读, 一个用于写
2. pipe(int[2]) 将创建一个新管道, 读写文件描述符记录在传入的数组中
   p[0]为管道读端, p[1]为管道写端
3. 经过fork后, 父进程和子进程的文件描述符都指向管道
4. 如果没有数据可用, read管道会等待数据被写入, 或者 , 等待所有指向写端的文件描述符被关闭.  后一种情况将返回0
5. 应该及时适当关闭管道写端, 否则某些进程将无限堵塞
6. shell 快捷使用管道  eg: echo hello world | wc , 通常作为使用临时文件的代替方式

### 文件系统

1. 路径形式:  `/a/b/c`  从根目录开始,  `a`从当前目录

2. chdir 改变进程的当前目录

3. mkdir创建一个新目录

4. mknod(string, int, int)创建设备文件

5. 知识盲区linux文件系统 :sob:
   [阮一峰老师关于inode介绍](https://www.ruanyifeng.com/blog/2011/12/inode.html)

6. fstat(fd, &st)从文件描述符引用的inode检索信息

7. link(char\*, char\*)创建一个引用了同一个inode的文件名

   unlink(char*)从文件系统中删除一个文件名

## Lab1

### # sleep

实验帮助

1. 阅读ch1
2. 可通过user/ 下的程序查看如何获取命令行参数. 注: user/ulib.c中有 atoi可进行转化字符串
3. 使用系统调用sleep
4. kernel/sysproc.c 中有xv6内核实现sleep系统调用的代码(sys_sleep)
   user/user.h中有sleep可执行程序的c声明
   user/usys.S中是有能从用户跳转到内核执行sleep的汇编代码
5. 确保使用exit跳出代码
6. 在Makeflie的 `UPROGS` 加入程序, make qemu将会进行编译

### # pingpong

实验帮助

1. 使用`pipe`创建管道
2. 使用`fork`创建子进程
3. 使用`read`读取pipe, 使用`write`写入pipe
4. 系统调用: `user/user.h`
   非系统调用: `user/ulib.c`, `user/printf.c`, `user/umalloc.c`

### # find

实验帮助

1. 查看ls.c学习如何如文件夹
2. 允许使用递归降至子目录
3. 不要递归进"." 和 ".."
4. make clean可以清除文件系统
5. 使用strcmp()处理字符串

### # xargs

实验帮助

1. 使用`fork`和`exec`激活每行的命令, 使用`wait`等待子进程退出
2. 读取每一行直到`\n`出现
3. `kernel/param.h`定义了`MAXARG`, 这可能有利于你声明一个参数数组

### # primes

实验帮助

1. 应当及时关闭不需要的文件描述符, 否则程序可能在到达35之前把xv6资源耗尽
2. 主程序应当在打印完后退出
3. `read`返回0当写端被关闭
4. 应当传入4字节int, 而不是使用ascii码
5. 只在需要时创建进程

### # uptime

done

### # 为find添加正则匹配

done

### # shell执行来自文件的命令时不打印"$ "

done

### # todo....

## 测试答案

1. make grade检查所有实验程序
2. ./grade-lab-util \*\*\*  或者 make GRADEFLAGS=\*\*\* grade检查单个程序

